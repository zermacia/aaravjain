<html>
<head>
<meta charset="UTF-8">
<title>Terminal Tag</title>
<link href="https://fonts.cdnfonts.com/css/satoshi" rel="stylesheet">
<style>
html,body{
  margin:0;
  background:#050000;
  overflow:hidden;
  font-family:'Satoshi', monospace;
}
canvas{display:block}

/* ---------- HUD ---------- */
#header{
  position:fixed;
  top:0; left:0; right:0;
  height:56px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:0 18px;
  background:rgba(20,0,0,0.75);
  border-bottom:1px solid rgba(255,80,80,0.35);
  backdrop-filter:blur(6px);
  z-index:10;
}
#timer{ font-size:22px; color:#ff5555; text-shadow:0 0 12px rgba(255,80,80,.6); }
#controls{ font-size:13px; color:#ffcccc; text-shadow:0 0 8px rgba(255,80,80,.4); }
#score{ font-size:15px; color:#ffffff; text-shadow:0 0 10px rgba(255,80,80,.5); }

/* ---------- MENU ---------- */
#menu{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.85);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:20;
}
#menuBox{
  border:1px solid #ff4444;
  padding:30px 40px;
  text-align:center;
  box-shadow:0 0 30px rgba(255,0,0,.5);
}
#menuBox h1{
  color:#ff5555;
  margin-bottom:20px;
}
.menuBtn{
  display:block;
  margin:10px auto;
  padding:10px 30px;
  background:#120000;
  border:1px solid #ff4444;
  color:#ff7777;
  cursor:pointer;
}

/* ---------- END ---------- */
#winner{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:76px;
  color:#ff3333;
  text-shadow:0 0 60px rgba(255,0,0,.85);
  pointer-events:none;
}
#restart{
  position:fixed;
  top:64%;
  left:50%;
  transform:translateX(-50%);
  padding:10px 26px;
  font-size:16px;
  background:#120000;
  border:1px solid #ff4444;
  color:#ff5555;
  cursor:pointer;
  display:none;
  box-shadow:0 0 20px rgba(255,0,0,.6);
}
</style>
</head>
<body>

<div id="menu">
  <div id="menuBox">
    <h1>TERMINAL TAG</h1>
    <button class="menuBtn" onclick="startMode('pvp')">1v1 LOCAL</button>
    <button class="menuBtn" onclick="startMode('ai')">VS COMPUTER</button>
  </div>
</div>

<div id="header">
  <div id="timer"></div>
  <div id="controls">AARAV: WASD + F | JAIN: ARROWS + J</div>
  <div id="score"></div>
</div>

<div id="winner"></div>
<button id="restart">RESTART</button>
<canvas id="c"></canvas>

<script>
/* ---------- CANVAS ---------- */
const c=document.getElementById("c");
const ctx=c.getContext("2d");
resize(); onresize=resize;
function resize(){ c.width=innerWidth; c.height=innerHeight; }

/* ---------- INPUT ---------- */
const keys={};
onkeydown=e=>keys[e.key]=true;
onkeyup=e=>keys[e.key]=false;

/* ---------- PLAYER ---------- */
function Player(x,y,name,controls,isAI=false){
  // Added basic AI state properties directly here to ensure they exist
  return {
    x,y,px:x,py:y,
    name,controls,isAI,
    speed:4.6,
    slowUntil:0,
    lastShot:0,
    // --- New AI Specific State ---
    aiState: 'idle',     // idle, chase, flee, recover
    aiMood: 'balanced',  // aggressive, defensive, balanced
    aiTargetX: 0, 
    aiTargetY: 0,
    aiVirtualX: 0,       // Simulates joystick X (-1 to 1)
    aiVirtualY: 0,       // Simulates joystick Y (-1 to 1)
    aiReactionTime: 0
  };
}

let p1,p2,itPlayer;
let bullets=[];
let gameStart=0,gameOver=false;
let tagCooldownUntil=0;
let glitchUntil=0;
let shakeUntil=0;
let shakeIntensity=0;
let mode=null;

const ROUND_TIME=30000;
const scores={aarav:0,jain:0};

/* ---------- PARTICLES ---------- */
const particles=Array.from({length:90},()=>({
  x:Math.random()*innerWidth,
  y:Math.random()*innerHeight,
  vx:0,vy:0,bx:0,by:0,
  r:2+Math.random()*3
}));
particles.forEach(p=>{p.bx=p.x;p.by=p.y;});

/* ---------- MENU ---------- */
function startMode(m){
  mode=m;
  menu.style.display="none";
  startGame();
}

/* ---------- INIT ---------- */
function startGame(){
  p1=new Player(220,340,"aarav","wasd",false);
  p2=new Player(640,340,"jain","arrows",mode==="ai");
  itPlayer=Math.random()<0.5?p1:p2;
  bullets=[];
  gameStart=performance.now();
  gameOver=false;
  tagCooldownUntil=0;
  glitchUntil=0;
  shakeUntil=0;
  winner.textContent="";
  restart.style.display="none";
}
restart.onclick=startGame;

/* ---------- LOOP ---------- */
function loop(t){
  let sx=0,sy=0;
  if(t<shakeUntil){
    sx=(Math.random()-0.5)*shakeIntensity;
    sy=(Math.random()-0.5)*shakeIntensity;
  }
  ctx.save();
  ctx.translate(sx,sy);

  ctx.fillStyle="#050000";
  ctx.fillRect(0,0,c.width,c.height);

  drawGrid();
  drawParticles();

  if(mode && !gameOver){
    updatePlayer(p1,t);
    p2.isAI ? updateAI(p2,t) : updatePlayer(p2,t);
    updateBullets(t);
    checkTag(t);
    updateTimer(t);
  }

  drawPlayers(t);
  drawScreenRGB(t);

  ctx.restore();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ---------- PLAYER UPDATE ---------- */
function updatePlayer(p,t){
  p.px=p.x; p.py=p.y;
  let s=t<p.slowUntil?2.6:p.speed;
  let dx=0,dy=0;

  if(p.controls==="wasd"){
    if(keys.w)dy--;
    if(keys.s)dy++;
    if(keys.a)dx--;
    if(keys.d)dx++;
    if(keys.f)shoot(p,t);
  }else{
    if(keys.ArrowUp)dy--;
    if(keys.ArrowDown)dy++;
    if(keys.ArrowLeft)dx--;
    if(keys.ArrowRight)dx++;
    if(keys.j)shoot(p,t);
  }

  p.x+=dx*s;
  p.y+=dy*s;
  p.x=Math.max(20,Math.min(c.width-20,p.x));
  p.y=Math.max(80,Math.min(c.height-20,p.y));
}

/* ---------- AI UPDATE (REWRITTEN) ---------- */
function updateAI(p, t) {
  p.px = p.x;
  p.py = p.y;
  
  let s = t < p.slowUntil ? 2.6 : p.speed;
  const target = p === p1 ? p2 : p1;
  const dist = Math.hypot(target.x - p.x, target.y - p.y);
  const isIt = (itPlayer === p);

  // 1. REACTION & THINKING CYCLE
  // Instead of updating logic every frame, we update 'decisions' every ~150-300ms
  if (t > p.aiReactionTime) {
    p.aiReactionTime = t + 120 + Math.random() * 150; // Human-like reaction delay

    // Update Mood randomly every few seconds
    if (Math.random() < 0.05) {
      const moods = ['aggressive', 'defensive', 'balanced'];
      p.aiMood = moods[Math.floor(Math.random() * moods.length)];
    }

    // 2. PREDICTION LOGIC
    // Calculate where the human player is GOING, not just where they ARE.
    const playerVx = target.x - target.px;
    const playerVy = target.y - target.py;
    const predictFactor = 15; // Look ahead 15 frames
    const predictedX = target.x + (playerVx * predictFactor);
    const predictedY = target.y + (playerVy * predictFactor);

    // 3. DECIDE TARGET based on Role (IT vs Not IT)
    if (isIt) {
      // Chase Logic
      if (p.aiMood === 'aggressive' || p.slowUntil > t) {
        // If slowed or aggressive, cut them off directly
        p.aiTargetX = predictedX;
        p.aiTargetY = predictedY;
      } else {
        // Balanced: Aim slightly behind them to catch turns
        p.aiTargetX = target.x;
        p.aiTargetY = target.y;
      }
    } else {
      // Flee Logic
      // Invert vector to run away
      const runDirX = p.x - target.x;
      const runDirY = p.y - target.y;
      
      // If cornered, try to slip to the center
      const nearWall = p.x < 100 || p.x > c.width - 100 || p.y < 150 || p.y > c.height - 100;
      
      if (nearWall && dist < 150) {
         // Panic maneuver: Dash to center
         p.aiTargetX = c.width / 2;
         p.aiTargetY = c.height / 2;
      } else {
         p.aiTargetX = p.x + runDirX;
         p.aiTargetY = p.y + runDirY;
      }
    }
  }

  // 4. MOMENTUM & INERTIA (The "Human" Feel)
  // Instead of setting velocity instantly to 1 or -1, we smooth the input.
  
  // Calculate raw direction to target
  let rawDx = p.aiTargetX - p.x;
  let rawDy = p.aiTargetY - p.y;
  
  // Normalize
  const rawDist = Math.hypot(rawDx, rawDy) || 1;
  const inputX = rawDx / rawDist;
  const inputY = rawDy / rawDist;

  // Apply inertia: Move 'virtual joystick' towards input slowly
  // 0.1 is the "responsiveness" factor. Lower = driftier/heavier. Higher = snappier.
  const responsiveness = isIt ? 0.15 : 0.12; 
  p.aiVirtualX += (inputX - p.aiVirtualX) * responsiveness;
  p.aiVirtualY += (inputY - p.aiVirtualY) * responsiveness;

  // Apply movement
  p.x += p.aiVirtualX * s;
  p.y += p.aiVirtualY * s;

  // 5. STRATEGIC SHOOTING
  // Don't shoot randomly. Shoot if aligned or if opponent is slowed (combo).
  // Check alignment
  const xAlign = Math.abs(p.x - target.x) < 40;
  const yAlign = Math.abs(p.y - target.y) < 40;
  
  // Cooldown check is handled inside shoot(), but AI needs a separate "desire" check
  let shouldShoot = false;

  // Rule 1: Always shoot if perfectly aligned (Sniper behavior)
  if ((xAlign || yAlign) && dist < 500) shouldShoot = true;

  // Rule 2: Panic fire if opponent is very close (Self defense)
  if (dist < 100 && Math.random() < 0.1) shouldShoot = true;

  // Rule 3: If I am chasing and they are far, shoot to slow them down
  if (isIt && dist > 300 && Math.random() < 0.02) shouldShoot = true;

  if (shouldShoot) {
     // Add a small delay/hesitation sometimes so it's not inhumanly perfect
     if(Math.random() > 0.1) shoot(p, t); 
  }

  // Boundary checks (Hard limits)
  p.x = Math.max(20, Math.min(c.width - 20, p.x));
  p.y = Math.max(80, Math.min(c.height - 20, p.y));
}


/* ---------- GAME LOGIC ---------- */
function checkTag(t){
  if(t<tagCooldownUntil) return;
  if(Math.hypot(p1.x-p2.x,p1.y-p2.y)<28){
    itPlayer=itPlayer===p1?p2:p1;
    tagCooldownUntil=t+500;
    glitchUntil=t+150;
    shakeUntil=t+150; shakeIntensity=6;
  }
}

function shoot(p,t){
  if(t-p.lastShot<5000) return;
  p.lastShot=t;
  const target=p===p1?p2:p1;
  
  // Small aim error for realism (AI isn't a perfect sniper)
  let error = p.isAI ? (Math.random() - 0.5) * 0.2 : 0; 
  
  const a=Math.atan2(target.y-p.y,target.x-p.x) + error;
  bullets.push({x:p.x,y:p.y,vx:Math.cos(a)*6,vy:Math.sin(a)*6,owner:p});
}

function updateBullets(t){
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    b.x+=b.vx; b.y+=b.vy;
    const target=b.owner===p1?p2:p1;
    if(Math.hypot(b.x-target.x,b.y-target.y)<14){
      target.slowUntil=t+3000;
      bullets.splice(i,1);
      continue;
    }
    if(b.x<0||b.y<80||b.x>c.width||b.y>c.height){
      bullets.splice(i,1); continue;
    }
    let g=ctx.createRadialGradient(b.x,b.y,0,b.x,b.y,6);
    g.addColorStop(0,"#fff");
    g.addColorStop(0.4,"#ff9999");
    g.addColorStop(1,"rgba(255,0,0,0)");
    ctx.fillStyle=g;
    ctx.shadowBlur=14; ctx.shadowColor="#ff5555";
    ctx.beginPath(); ctx.arc(b.x,b.y,6,0,Math.PI*2); ctx.fill();
    ctx.shadowBlur=0;
  }
}

function updateTimer(t){
  const left=Math.max(0,ROUND_TIME-(t-gameStart));
  timer.textContent="Time: "+Math.ceil(left/1000);
  if(left<=0 && !gameOver){
    gameOver=true;
    const w=itPlayer===p1?p2:p1;
    scores[w.name]++;
    winner.textContent=w.name.toUpperCase()+" WINS";
    restart.style.display="block";
  }
  score.textContent=`AARAV ${scores.aarav}  |  JAIN ${scores.jain}`;
}

/* ---------- DRAW ---------- */
function drawPlayers(t){
  ctx.font="32px Satoshi, monospace";
  [p1,p2].forEach(p=>{
    if(!p) return;
    const base=p===itPlayer?"#ff3333":"#ffffff";
    const glow=p===itPlayer?30:14;
    const dx=p.x-p.px, dy=p.y-p.py;
    for(let i=1;i<=3;i++){
      ctx.globalAlpha=0.12/i;
      ctx.fillStyle=base;
      ctx.fillText(p.name,p.x-dx*i-22,p.y-dy*i+6);
    }
    ctx.globalAlpha=1;
    if(t<glitchUntil){
      drawRGBText(p.name,p.x,p.y);
    }else{
      ctx.shadowBlur=glow;
      ctx.shadowColor=base;
      ctx.fillStyle=base;
      ctx.fillText(p.name,p.x-22,p.y+6);
      ctx.shadowBlur=0;
    }
  });
}

function drawRGBText(text,x,y){
  ctx.fillStyle="rgba(255,0,0,0.9)";
  ctx.fillText(text,x-20+2,y+6);
  ctx.fillStyle="rgba(0,255,0,0.25)";
  ctx.fillText(text,x-20,y+6);
  ctx.fillStyle="rgba(0,200,255,0.6)";
  ctx.fillText(text,x-20-2,y+6);
}

function drawScreenRGB(t){
  if(t>glitchUntil) return;
  ctx.globalAlpha=0.06;
  ctx.drawImage(c,2,0);
  ctx.drawImage(c,-2,0);
  ctx.globalAlpha=1;
}

function drawParticles(){
  for(const p of particles){
    let fx=0,fy=0;
    [p1,p2].forEach(pl=>{
      if(!pl) return;
      const dx=p.x-pl.x, dy=p.y-pl.y;
      const d=Math.hypot(dx,dy);
      if(d<140){
        const f=(140-d)/140;
        fx+=dx/d*f*0.5;
        fy+=dy/d*f*0.5;
      }
    });
    p.vx=(p.vx+fx)*0.9;
    p.vy=(p.vy+fy)*0.9;
    p.x+=p.vx; p.y+=p.vy;
    p.x+=(p.bx-p.x)*0.01;
    p.y+=(p.by-p.y)*0.01;
    const glow=Math.min(1,Math.hypot(p.vx,p.vy)*2);
    ctx.fillStyle=`rgba(255,0,0,${0.12+glow*0.25})`;
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.r+glow*1.5,0,Math.PI*2);
    ctx.fill();
  }
}

function drawGrid(){
  ctx.strokeStyle="rgba(255,0,0,0.05)";
  for(let x=0;x<c.width;x+=70){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,c.height); ctx.stroke();
  }
  for(let y=80;y<c.height;y+=70){
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(c.width,y); ctx.stroke();
  }
}
</script>
</body>
</html>
